---
title: "Trabalho Econometria II"
author: "Grupo 6"
date: "20/01/2021"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# Lendo o arquivo e ajustando o período de tempo da base
library(tidyverse)
library(readr)
emprego <- read_csv("C:/Users/angel/Downloads/ipeadata[20-01-2021-02-19].csv")
emprego <- emprego %>% 
  rename(Saldo = `Empregados - saldo - Pessoa - Ministério do Trabalho e Emprego- Cadastro Geral de Empregados e Desempregados (MTE/CAGED) - CAGED12_SALDO12`) %>% 
  select(Data, Saldo)
emprego <- emprego %>% 
  filter(Data > 2000.01)
emprego_ts <- ts(emprego, start = c(2000, 1), frequency = 12)
```

```{r}
##################################### PARTE 1: IDENTIFICAÇÃO DA SÉRIE
# plotando o gráfico da série temporal
plot(emprego_ts[,2], xlab = "Período", ylab = "Saldo",
     main = "Saldo de empregos formais ao longo dos anos")
# Decompondo a série
plot(decompose(emprego_ts[,2]))
```

```{r}
# pacote para teste de raíz unitária
library(urca)
par(mfrow = c(1,1))
# FAC e FACP em nível
acf(emprego_ts[,2], xlab = "Defasagem", ylab = "FAC", 
    main = "Função de autocorrelação (em nível)", lag.max = 48)
pacf(emprego_ts[,2], xlab = "Defasagem", ylab = "FACP",
     main = "Função de autocorrelação parcial (em nível)", lag.max = 48)
# teste de raíz unitária (ADF) - variável em nível - não estacionário
summary(ur.df(emprego_ts[,2], type = c("none"), lags = 24, selectlags = "BIC"))
summary(ur.df(emprego_ts[,2], type = c("drift"), lags = 24, selectlags = "BIC"))
summary(ur.df(emprego_ts[,2], type = c("trend"), lags = 24, selectlags = "BIC"))
# teste de raíz unitária (PP) - variável em nível - estacionário
summary(ur.pp(emprego_ts[,2], type = c("Z-tau"), model = c("constant"), lags = c("short")))
summary(ur.pp(emprego_ts[,2], type = c("Z-tau"), model = c("trend"), lags = c("short")))
# teste de raíz unitária (KPSS) - variável em nível - não estacionário
# LEMBRETE: H0 nesse teste é a hipótese de que a variável é estacionária
summary(ur.kpss(emprego_ts[,2], type = c("mu"), lags = c("short")))
summary(ur.kpss(emprego_ts[,2], type = c("tau"), lags = c("short")))
```

```{r}
# primeira diferença sazonal da série
plot(diff(emprego_ts[,2], lag = 12, differences = 1), ylab = "", xlab = "Período",
     main = "Primeira diferença sazonal do emprego\nformal no tempo")
# primeira diferença sazonal
acf(diff(emprego_ts[,2], lag = 12), lag.max = 48,
main = "Função de autocorrelação\n(primeira diferença sazonal)", ylab = "FAC", xlab = "Defasagem")
pacf(diff(emprego_ts[,2], lag = 12), lag.max = 48,
main = "Função de autocorrelação parcial\n(primeira diferença sazonal)", ylab = "FACP", xlab = "Defasagem")
# teste de raíz unitária (ADF) - variável em nível e primeira diferença sazonal - estacionário
summary(ur.df(diff(emprego_ts[,2], lag = 12), type = c("none"), lags = 24, selectlags = "BIC"))
summary(ur.df(diff(emprego_ts[,2], lag = 12), type = c("drift"), lags = 24, selectlags = "BIC"))
summary(ur.df(diff(emprego_ts[,2], lag = 12), type = c("trend"), lags = 24, selectlags = "BIC"))
# teste de raíz unitária (PP) - variável em nível e primeira diferença sazonal - estacionário
summary(ur.pp(diff(emprego_ts[,2], lag = 12), type = c("Z-tau"), model = c("constant"), lags = c("short")))
summary(ur.pp(diff(emprego_ts[,2], lag = 12), type = c("Z-tau"), model = c("trend"), lags = c("short")))
# teste de raíz unitária (KPSS) - variável em nível e primeira diferença sazonal - estacionário
# LEMBRETE: H0 nesse teste é a hipótese de que a variável é estacionária
summary(ur.kpss(diff(emprego_ts[,2], lag = 12), type = c("mu"), lags = c("short")))
summary(ur.kpss(diff(emprego_ts[,2], lag = 12), type = c("tau"), lags = c("short")))
```

```{r}
##################################### PARTE 2: ESTIMAÇÃO
# estimação do modelo SARIMA
library(forecast)
library(tseries)
library(FitAR)
library(FinTS)
library(lmtest)

# Modelos candidatos: SARIMA(p,d,q)(P,D,Q) com combinações de ordem d = 0 e D = 1 e  p, P, q, Q
fit1 <- coeftest(Arima(emprego_ts[,2], order = c(1,0,1), seasonal = list(order = c(0,1,0), period = 12))); fit1 
fit2 <- coeftest(Arima(emprego_ts[,2], order = c(1,0,2), seasonal = list(order = c(0,1,0), period = 12))); fit2 
fit3 <- coeftest(Arima(emprego_ts[,2], order = c(2,0,1), seasonal = list(order = c(0,1,0), period = 12))); fit3 # ma1 não significativo
fit4 <- coeftest(Arima(emprego_ts[,2], order = c(2,0,2), seasonal = list(order = c(1,1,0), period = 12))); fit4 # somente sar1 significativo
fit5 <- coeftest(Arima(emprego_ts[,2], order = c(1,0,2), seasonal = list(order = c(1,1,1), period = 12))); fit5 # sar1 não significativo
fit6 <- coeftest(Arima(emprego_ts[,2], order = c(1,0,2), seasonal = list(order = c(1,1,2), period = 12))); fit6 # sma1 não significativo
fit7 <- coeftest(Arima(emprego_ts[,2], order = c(1,0,2), seasonal = list(order = c(2,1,1), period = 12))); fit7 # sar1 e sar não significativos
fit8 <- coeftest(auto.arima(emprego_ts[,2])); fit8 
```

```{r}
# Análise dos critérios de informação dos modelos candidatos
# (melhores modelos são os que possuem menor critério de informação)
mod1 <- Arima(emprego_ts[,2], order = c(1,0,1), seasonal = list(order = c(0,1,0), period = 12))
mod2 <- Arima(emprego_ts[,2], order = c(1,0,2), seasonal = list(order = c(0,1,0), period = 12))
mod3 <- Arima(emprego_ts[,2], order = c(2,0,1), seasonal = list(order = c(0,1,0), period = 12))
mod4 <- Arima(emprego_ts[,2], order = c(2,0,2), seasonal = list(order = c(1,1,0), period = 12))
mod5 <- Arima(emprego_ts[,2], order = c(1,0,2), seasonal = list(order = c(1,1,1), period = 12))
mod6 <- Arima(emprego_ts[,2], order = c(1,0,2), seasonal = list(order = c(1,1,2), period = 12))
mod7 <- Arima(emprego_ts[,2], order = c(1,0,2), seasonal = list(order = c(2,1,1), period = 12))
mod8 <- auto.arima(emprego_ts[,2])
# critério Akaike e Bayesiano
AIC(mod1, mod2, mod3, mod4,mod5, mod6, mod7, mod8) # mod5 e mod8
BIC(mod1, mod2, mod3, mod4,mod5, mod6, mod7, mod8) # mod5 e mod8
```

```{r}
##################################### PARTE 3: VERIFICAÇÃO DO MODELO AJUSTADO

```
# foram verificados os modelos 5 e 8 de acordo com os critérios menores de AIC e BIC 

# Teste de estabilidade
autoplot(mod5)
autoplot(mod7)
autoplot(mod8)

# Testes dos resíduos
res5<-residuals(mod5)
res7<-residuals(mod7)
res8<-residuals(mod8)

## Autocorrelação - Teste de Ljung-Box
##H0: os residuos sao iid
tsdiag(mod5)
Box.test(res5,lag=12,type="Ljung-Box")
Box.test(res5,lag=24,type="Ljung-Box")
Box.test(res5,lag=36,type="Ljung-Box")
Box.test(res5,lag=48,type="Ljung-Box")

tsdiag(mod7)
Box.test(res7,lag=12,type="Ljung-Box")
Box.test(res7,lag=24,type="Ljung-Box")
Box.test(res7,lag=36,type="Ljung-Box")
Box.test(res7,lag=48,type="Ljung-Box")

tsdiag(mod8)
Box.test(res8,lag=12,type="Ljung-Box")
Box.test(res8,lag=24,type="Ljung-Box")
Box.test(res8,lag=36,type="Ljung-Box")
Box.test(res8,lag=48,type="Ljung-Box")

## Normalidade                      
##Teste de Jarque-Bera
##H0: normalidade dos residuos
par(mfrow=c(2,2)) ##colocar 2 em cima e 2 embaixo
hist(res5, freq=F, ylab='Densidade', xlab='Resíduos', main='Resíduos')
plot(density(res5, kernel = c("gaussian")), main="Resíduos")   #Função de densidade estimada
qqnorm(res5, ylab='Quantis amostrais', xlab='Quantis teóricos', main='Quantil-Quantil')
qqline(res5, col = "red")
shapiro.test(res5)
jarque.bera.test(res5)

par(mfrow=c(2,2))
hist(res7, freq=F, ylab='Densidade', xlab='Resíduos', main='Resíduos')
plot(density(res8, kernel = c("gaussian")), main="Resíduos")   #Função de densidade estimada
qqnorm(res7, ylab='Quantis amostrais', xlab='Quantis teóricos', main='Quantil-Quantil')
qqline(res7, col = "red")
shapiro.test(res7)
jarque.bera.test(res7)

par(mfrow=c(1,1))
hist(res8, freq=F, ylab='Densidade', xlab='Resíduos', main='Resíduos')
plot(density(res8, kernel = c("gaussian")), main="Resíduos")   #Função de densidade estimada
qqnorm(res8, ylab='Quantis amostrais', xlab='Quantis teóricos', main='Quantil-Quantil')
qqline(res8, col = "red")
shapiro.test(res8)
jarque.bera.test(res8)


# Teste de Heteroscedasticidade     
##Teste ARCH
##H0: os residuos nao possuem efeitos auto-regressivos de heteroscedasticidade condicional
ArchTest(res5,lags = 12)
ArchTest(res7,lags = 12)
ArchTest(res8,lags = 12)
